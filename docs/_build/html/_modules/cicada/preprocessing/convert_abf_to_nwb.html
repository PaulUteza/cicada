

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cicada.preprocessing.convert_abf_to_nwb &mdash; CICADA 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../../_static/sphinxcontrib-images\LightBox2\lightbox2\js\jquery-1.11.0.min.js"></script>
        <script type="text/javascript" src="../../../_static/sphinxcontrib-images\LightBox2\lightbox2\js\lightbox.min.js"></script>
        <script type="text/javascript" src="../../../_static/sphinxcontrib-images\LightBox2\lightbox2-customize\jquery-noconflict.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/sphinxcontrib-images\LightBox2\lightbox2\css\lightbox.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: white" >
          

          
            <a href="../../../index.html" class="icon icon-home"> CICADA
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">How to install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial.html">How to use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../preprocessing.html">Pre-processing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.cicada_data_to_nwb">Data to NWB</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.cicada_preprocessing_run">Run preprocessing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.convert_to_nwb">NWB file class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.convert_suite_2p_rois_to_nwb">Suite 2P ROIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.convert_processed_2d_series_to_nwb">2D series</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.convert_ci_movie_to_nwb">Calcium imaging movie</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.convert_abf_to_nwb">ABF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#module-cicada.preprocessing.utils">Utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../preprocessing.html#annexe">Annexe</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html">Analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_analysis">Main analysis class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_analysis_arguments_handler">Argument handler</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_analysis_format_wrapper">Format wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_analysis_nwb_wrapper">NWB wrapper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_cells_count">Cells count</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_connectivity_graph">Connectivity graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_frames_count">Frames count</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_hubs_analysis">Hubs analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#module-cicada.analysis.cicada_psth_analysis">PSTH analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../analysis.html#annexe">Annexe</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../gui.html">GUI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.cicada_main_window">Main Window</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.session_show_filter_group">Filter/group sessions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.metadata_widget">Display metadata</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.cicada_analysis_tree_gui">Analysises list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.cicada_analysis_overview">Overview of analysises</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../gui.html#module-cicada.gui.cicada_analysis_parameters_gui">Analysis parameters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/pappyhammer/cicada">See on Git</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CICADA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>cicada.preprocessing.convert_abf_to_nwb</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cicada.preprocessing.convert_abf_to_nwb</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">cicada.preprocessing.convert_to_nwb</span> <span class="k">import</span> <span class="n">ConvertToNWB</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">pyabf</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">pynwb.base</span> <span class="k">import</span> <span class="n">TimeSeries</span>
<span class="kn">from</span> <span class="nn">cicada.preprocessing.utils</span> <span class="k">import</span> <span class="n">get_continous_time_periods</span><span class="p">,</span> <span class="n">merging_time_periods</span><span class="p">,</span> <span class="n">class_name_to_file_name</span>

<div class="viewcode-block" id="ConvertAbfToNWB"><a class="viewcode-back" href="../../../preprocessing.html#cicada.preprocessing.convert_abf_to_nwb.ConvertAbfToNWB">[docs]</a><span class="k">class</span> <span class="nc">ConvertAbfToNWB</span><span class="p">(</span><span class="n">ConvertToNWB</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class to convert ABF data to NWB &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nwb_file</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">nwb_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># array of integers representing the index at which the frame has been acquired</span>
        <span class="c1"># the indices is used in sweepY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># means if there are more than one movie, we consider it as one movie (concatenation of the segments)</span>
        <span class="c1"># without any breaks in the movie</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fusion_movie_segments</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate_calcium_imaging</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># contains the frames indices (matching self.ci_frames_indices) after which there is a gap (for ex when</span>
        <span class="c1"># 2 movies are concatenated)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int16&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="ConvertAbfToNWB.convert"><a class="viewcode-back" href="../../../preprocessing.html#cicada.preprocessing.convert_abf_to_nwb.ConvertAbfToNWB.convert">[docs]</a>    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The goal of this function is to extract from an Axon Binary Format (ABF) file its content</span>
<span class="sd">        and make it accessible through the NWB file.</span>
<span class="sd">        The content can be: LFP signal, piezzo signal, speed of the animal on the treadmill. All, None or a few</span>
<span class="sd">        of these informations could be available.</span>
<span class="sd">        One information always present is the timestamps, at the abf sampling_rate, of the frames acquired</span>
<span class="sd">        by the microscope to create the calcium imaging movie. Such movie could be the concatenation of a few</span>
<span class="sd">        movies, such is the case if the movie need to be saved every x frames for memory issue for ex.</span>
<span class="sd">        If the movie is the concatenation of many, then there is an option to choose to extract the information as</span>
<span class="sd">        if 2 frames concatenate are contiguous in times (such as then LFP signal or piezzo would be match movie),</span>
<span class="sd">        or to add interval_times indicating at which time the recording is on pause and at which time it&#39;s starting</span>
<span class="sd">        again. The time interval containing this information is named &quot;ci_recording_on_pause&quot; and you can get it</span>
<span class="sd">        doing:</span>
<span class="sd">        if &#39;ci_recording_on_pause&#39; in nwb_file.intervals:</span>
<span class="sd">        pause_intervals = nwb_file.intervals[&#39;ci_recording_on_pause&#39;]</span>

<span class="sd">        Args:</span>
<span class="sd">            **kwargs (dict) : kwargs is a dictionary, potentials keys and values types are:</span>
<span class="sd">            abf_yaml_file_name: mandatory parameter. The value is a string representing the path</span>
<span class="sd">            and file_name of the yaml file associated to this abf file. In the abf:</span>
<span class="sd">            frames_channel: mandatory parameter. The value is an int representing the channel</span>
<span class="sd">            of the abf in which is the frames timestamps data.</span>
<span class="sd">            abf_file_name: mandatory parameter. The value is a string representing the path</span>
<span class="sd">            and file_name of the abf file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;abf_yaml_file_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;&#39;abf_yaml_file&#39; argument should be pass to convert &quot;</span>
                            <span class="n">f</span><span class="s2">&quot;function in class </span><span class="si">{self.__class__.__name__}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;abf_file_name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;&#39;abf_file_name&#39; argument should be pass to convert &quot;</span>
                            <span class="n">f</span><span class="s2">&quot;function in class </span><span class="si">{self.__class__.__name__}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;fusion_movie_segments&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fusion_movie_segments</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fusion_movie_segments&quot;</span><span class="p">])</span>

        <span class="c1"># yaml_file that will contains the information to read the abf file</span>
        <span class="n">abf_yaml_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;abf_yaml_file_name&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">abf_yaml_file_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">abf_yaml_file_name</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
            <span class="n">abf_yaml_data</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">safe_load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;frames_channel&quot;</span> <span class="ow">in</span> <span class="n">abf_yaml_data</span><span class="p">:</span>
            <span class="n">frames_channel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">abf_yaml_data</span><span class="p">[</span><span class="s2">&quot;frames_channel&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;No &#39;frames_channel&#39; provided in the yaml file &quot;</span>
                            <span class="n">f</span><span class="s2">&quot;</span><span class="si">{abf_yaml_file_name}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># key is an int representing a channel index, value is a list of 1 or 2 elements, first element is a string</span>
        <span class="c1"># caraterazing the channel name and the second element (optionnal) is the new sampling_rate in which saving</span>
        <span class="c1"># the data. If not present, the original sampling_rate will be kept</span>
        <span class="n">channels_to_save_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># channel with the LFP data</span>
        <span class="n">lfp_channel</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lfp_channel&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lfp_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">lfp_channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;LFP&quot;</span><span class="p">]</span>
            <span class="c1"># give the sampling rate to use for downsampling the lfp and record</span>
            <span class="c1"># it in the nwb file. If no argument, then the original sampling_rate will be kept</span>
            <span class="n">lfp_downsampling_hz</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lfp_downsampling_hz&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lfp_downsampling_hz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">lfp_channel</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lfp_downsampling_hz</span><span class="p">)</span>

        <span class="c1"># channel with the run data</span>
        <span class="n">run_channel</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;run_channel&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">run_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">run_channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;run&quot;</span><span class="p">]</span>

        <span class="c1"># channel with the piezzo data (could be more than one channel</span>
        <span class="n">piezo_channels</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;piezo_channels&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">piezo_channels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">piezo_channels</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># converting int in list</span>
                <span class="n">piezo_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">piezo_channels</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">piezo_channel</span> <span class="ow">in</span> <span class="n">piezo_channels</span><span class="p">:</span>
                <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">piezo_channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;piezo_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">piezo_channel</span><span class="p">)]</span>
                <span class="n">piezzo_downsampling_hz</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;piezo_downsampling_hz&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">piezzo_downsampling_hz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">piezo_channel</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piezzo_downsampling_hz</span><span class="p">)</span>

        <span class="c1"># if given, indicated an offset to be taken in consideration between the data acquisition</span>
        <span class="c1"># and the frames</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">abf_yaml_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">)</span>

        <span class="n">abf_file_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;abf_file_name&quot;</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        dir(abf):</span>
<span class="sd">        abf [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, </span>
<span class="sd">        &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, </span>
<span class="sd">        &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, </span>
<span class="sd">        &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_adcSection&#39;, &#39;_cacheStimulusFiles&#39;, </span>
<span class="sd">        &#39;_dacSection&#39;, &#39;_dataGain&#39;, &#39;_dataOffset&#39;, &#39;_dtype&#39;, &#39;_epochPerDacSection&#39;, &#39;_epochSection&#39;, </span>
<span class="sd">        &#39;_fileSize&#39;, &#39;_headerV2&#39;, &#39;_ide_helper&#39;, &#39;_loadAndScaleData&#39;, &#39;_makeAdditionalVariables&#39;, </span>
<span class="sd">        &#39;_nDataFormat&#39;, &#39;_preLoadData&#39;, &#39;_protocolSection&#39;, &#39;_readHeadersV1&#39;, &#39;_readHeadersV2&#39;, </span>
<span class="sd">        &#39;_sectionMap&#39;, &#39;_stringsIndexed&#39;, &#39;_stringsSection&#39;, &#39;_sweepBaselinePoints&#39;, &#39;_tagSection&#39;, </span>
<span class="sd">        &#39;abfDateTime&#39;, &#39;abfDateTimeString&#39;, &#39;abfFileComment&#39;, &#39;abfFilePath&#39;, &#39;abfID&#39;, &#39;abfVersion&#39;, </span>
<span class="sd">        &#39;abfVersionString&#39;, &#39;adcNames&#39;, &#39;adcUnits&#39;, &#39;channelCount&#39;, &#39;channelList&#39;, &#39;creatorVersion&#39;, </span>
<span class="sd">        &#39;creatorVersionString&#39;, &#39;dacNames&#39;, &#39;dacUnits&#39;, &#39;data&#39;, &#39;dataByteStart&#39;, &#39;dataLengthMin&#39;, </span>
<span class="sd">        &#39;dataLengthSec&#39;, &#39;dataPointByteSize&#39;, &#39;dataPointCount&#39;, &#39;dataPointsPerMs&#39;, &#39;dataRate&#39;, </span>
<span class="sd">        &#39;dataSecPerPoint&#39;, &#39;fileGUID&#39;, &#39;headerHTML&#39;, &#39;headerLaunch&#39;, &#39;headerMarkdown&#39;, &#39;headerText&#39;, </span>
<span class="sd">        &#39;holdingCommand&#39;, &#39;launchInClampFit&#39;, &#39;protocol&#39;, &#39;protocolPath&#39;, &#39;saveABF1&#39;, &#39;setSweep&#39;, </span>
<span class="sd">        &#39;stimulusByChannel&#39;, &#39;stimulusFileFolder&#39;, &#39;sweepC&#39;, &#39;sweepChannel&#39;, &#39;sweepCount&#39;, &#39;sweepD&#39;, </span>
<span class="sd">        &#39;sweepEpochs&#39;, &#39;sweepIntervalSec&#39;, &#39;sweepLabelC&#39;, &#39;sweepLabelX&#39;, &#39;sweepLabelY&#39;, &#39;sweepLengthSec&#39;, </span>
<span class="sd">        &#39;sweepList&#39;, &#39;sweepNumber&#39;, &#39;sweepPointCount&#39;, &#39;sweepUnitsC&#39;, &#39;sweepUnitsX&#39;, &#39;sweepUnitsY&#39;, </span>
<span class="sd">        &#39;sweepX&#39;, &#39;sweepY&#39;, &#39;tagComments&#39;, &#39;tagSweeps&#39;, &#39;tagTimesMin&#39;, &#39;tagTimesSec&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abf</span> <span class="o">=</span> <span class="n">pyabf</span><span class="o">.</span><span class="n">ABF</span><span class="p">(</span><span class="n">abf_file_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">FileNotFoundError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Abf file not found: </span><span class="si">{abf_file_name}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># raise Exception(&quot;NOT TODAY&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">sweepNumber</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">frames_channel</span><span class="p">)</span>
        <span class="n">timestamps_in_sec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">sweepX</span>
        <span class="c1"># timestamps_in_sec = np.arange(len(self.abf.sweepY)) * (1 / self.abf.dataRate)</span>
        <span class="c1"># to avoid issue with float approximation, we compute ourself the timestamps and in ms</span>
        <span class="n">timestamps_in_ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">sweepY</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">sweepY</span>
        <span class="c1"># first frame corresponding at the first frame recorded in the calcium imaging movie</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span> <span class="o">=</span> <span class="n">timestamps_in_sec</span><span class="p">[:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span> <span class="o">=</span> <span class="n">timestamps_in_ms</span><span class="p">[:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span><span class="p">]</span>
        <span class="c1"># to avoid issue with float approximation, we compute ourself the timestamps</span>
        <span class="c1"># to avoid issue with float approximation, we compute ourself the timestamps</span>
        <span class="c1"># print(f&quot;self.abf.dataSecPerPoint {self.abf.dataSecPerPoint}&quot;)</span>
        <span class="c1"># print(f&quot;self.timestamps_in_ms[:10] {self.timestamps_in_ms[:10]}&quot;)</span>

        <span class="c1"># determining ci_frames_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">determine_ci_frames_indices</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;abf number of channels: </span><span class="si">{self.abf.channelCount}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;channels_to_save_dict </span><span class="si">{channels_to_save_dict}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">current_channel</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">channelCount</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">current_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels_to_save_dict</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">current_channel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;run&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_run_data</span><span class="p">(</span><span class="n">run_channel</span><span class="o">=</span><span class="n">run_channel</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># so far this code only analyse run and lfp channel</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">current_channel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;LFP&quot;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">current_channel</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;piezo&quot;</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">sweepNumber</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">current_channel</span><span class="p">)</span>
            <span class="c1"># abf_current_channel_data == mvt_data from the previous version</span>
            <span class="n">abf_current_channel_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">sweepY</span>
            <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">abf_current_channel_data</span> <span class="o">=</span> <span class="n">abf_current_channel_data</span> <span class="o">+</span> <span class="n">offset</span>
            <span class="n">abf_current_channel_data</span> <span class="o">=</span> <span class="n">abf_current_channel_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">first_frame_index</span><span class="p">:]</span>

            <span class="c1"># for LFP we used in the past down_sampling at 1000 Hz and for piezo 50 Hz</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">current_channel</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">down_sampling_hz</span> <span class="o">=</span> <span class="n">channels_to_save_dict</span><span class="p">[</span><span class="n">current_channel</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">down_sampling_hz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span>

            <span class="n">sampling_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span> <span class="o">/</span> <span class="n">down_sampling_hz</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fusion_movie_segments</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">last_index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">abf_current_channel_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">abf_data_to_save</span> <span class="o">=</span> <span class="n">abf_current_channel_data</span><span class="p">[:</span><span class="n">last_index</span><span class="p">:</span><span class="n">sampling_step</span><span class="p">]</span>
                <span class="n">abf_data_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">abf_data_to_save</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abf_current_channel_data</span><span class="p">[</span><span class="n">last_index</span><span class="p">]])))</span>
                <span class="n">timestamps_to_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[:</span><span class="n">last_index</span><span class="p">:</span><span class="n">sampling_step</span><span class="p">]</span>
                <span class="n">timestamps_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">timestamps_to_save</span><span class="p">,</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="n">last_index</span><span class="p">]])))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">abf_data_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">timestamps_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># +1 to get the first frame of the segment</span>
                <span class="n">segments_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># print(f&quot;segments_indices {segments_indices}&quot;)</span>
                <span class="k">for</span> <span class="n">index_segt</span><span class="p">,</span> <span class="n">segt_first_frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments_indices</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index_segt</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">last_abf_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">last_abf_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">segments_indices</span><span class="p">[</span><span class="n">index_segt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">last_abf_frame</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">abf_current_channel_data</span><span class="p">):</span>
                        <span class="n">last_abf_frame</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="c1"># sampling_step is produced according to a down_sampling_hz that changes</span>
                    <span class="c1"># according to the channel (lfp, piezzo etc...)</span>
                    <span class="n">new_data</span> <span class="o">=</span> <span class="n">abf_current_channel_data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">segt_first_frame</span><span class="p">],</span>
                                                                  <span class="n">last_abf_frame</span><span class="p">,</span> <span class="n">sampling_step</span><span class="p">)]</span>
                    <span class="n">new_timestamps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">segt_first_frame</span><span class="p">]:</span><span class="n">last_abf_frame</span><span class="p">:</span>
                                                            <span class="n">sampling_step</span><span class="p">]</span>
                    <span class="c1"># by adding the last_abf_frame we change the interval of time between the two last elements</span>
                    <span class="c1"># but this allow to keep the data well aligned</span>
                    <span class="n">abf_data_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">abf_data_to_save</span><span class="p">,</span> <span class="n">new_data</span><span class="p">,</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abf_current_channel_data</span><span class="p">[</span><span class="n">last_abf_frame</span><span class="p">]])))</span>
                    <span class="n">timestamps_to_save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">timestamps_to_save</span><span class="p">,</span> <span class="n">new_timestamps</span><span class="p">,</span>
                                                       <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="n">last_abf_frame</span><span class="p">]])))</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">lfp_channel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">lfp_channel</span> <span class="o">==</span> <span class="n">current_channel</span><span class="p">):</span>
                <span class="n">name_channel</span> <span class="o">=</span> <span class="s2">&quot;LFP&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name_channel</span> <span class="o">=</span> <span class="s2">&quot;piezo_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">piezo_channels</span> <span class="o">==</span> <span class="n">current_channel</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># given the conversion factor to get the timestamps in sec</span>
            <span class="c1"># we record them in ms to have a better precision</span>
            <span class="n">time_series</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name_channel</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="n">abf_data_to_save</span><span class="p">,</span>
                <span class="n">timestamps</span><span class="o">=</span><span class="n">timestamps_to_save</span><span class="p">,</span>
                <span class="n">conversion</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span>
                <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
            <span class="c1"># record the data as an acquisition</span>
            <span class="c1"># to recover the data do: nwb_file.get_acquisition(name=name_channel)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nwb_file</span><span class="o">.</span><span class="n">add_acquisition</span><span class="p">(</span><span class="n">time_series</span><span class="p">)</span></div>

<div class="viewcode-block" id="ConvertAbfToNWB.determine_ci_frames_indices"><a class="viewcode-back" href="../../../preprocessing.html#cicada.preprocessing.convert_abf_to_nwb.ConvertAbfToNWB.determine_ci_frames_indices">[docs]</a>    <span class="k">def</span> <span class="nf">determine_ci_frames_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the frames data channel, estimate the timestamps of each frame of the calcium imaging movie.</span>
<span class="sd">        If there are breaks between each recording (the movie being a concatenation of different movies), then</span>
<span class="sd">        there is an option to either skip those non registered frames that will be skept in all other data (lfp, piezzo,</span>
<span class="sd">        ...) or to determine how many frames to add in the movie and where so it matches the other data recording in</span>
<span class="sd">        the abf file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">threshold_value</span> <span class="o">=</span> <span class="mf">0.02</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">:</span>
            <span class="c1"># TODO: take in consideration the case when the sampling rate is less than 50k</span>
            <span class="c1">#  when it comes to  ci_frames_indices times_intervals</span>
            <span class="c1"># frames_data represent the content of the abf channel that contains the frames</span>
            <span class="c1"># the index stat at the first frame recorded, meaning the first value where the</span>
            <span class="c1"># value is &lt; 0.01</span>
            <span class="n">mask_frames_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="c1"># we need to detect the frames manually, but first removing data between movies</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">&gt;=</span> <span class="n">threshold_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mask_selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">selection</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
            <span class="c1"># looking for continuous data between movies</span>
            <span class="n">to_keep_for_removing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">mask_selection</span><span class="p">[</span><span class="n">to_keep_for_removing</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="p">[</span><span class="n">mask_selection</span><span class="p">]</span>
            <span class="c1"># we remove the &quot;selection&quot; from the frames data</span>
            <span class="n">mask_frames_data</span><span class="p">[</span><span class="n">selection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">frames_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span><span class="p">[</span><span class="n">mask_frames_data</span><span class="p">]</span>

            <span class="n">active_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames_data</span><span class="p">),</span> <span class="mi">12500</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">mean_diff_active_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">active_frames</span><span class="p">))</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span>
            <span class="k">if</span> <span class="n">mean_diff_active_frames</span> <span class="o">&lt;</span> <span class="mf">0.09</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;mean_diff_active_frames &lt; 0.09&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binary_frames_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">)</span>
            <span class="n">binary_frames_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">&gt;=</span> <span class="n">threshold_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">binary_frames_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">frames_data</span> <span class="o">&lt;</span> <span class="n">threshold_value</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># +1 due to the shift of diff</span>
            <span class="c1"># contains the index at which each frame from the movie is matching the abf signal</span>
            <span class="c1"># length should be 12500</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">binary_frames_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># then we want to determine the size of the breaks between each movie segment if there are some</span>
            <span class="n">diff_active_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">)</span>
            <span class="c1"># calculating the gap threshold above which we estimate the movie recording has been on hold</span>
            <span class="n">median_bw_two_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">diff_active_frames</span><span class="p">)</span>
            <span class="n">frames_gap_threshold</span> <span class="o">=</span> <span class="n">median_bw_two_frames</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">diff_active_frames</span><span class="p">)</span>
            <span class="c1"># print(f&quot;median_bw_two_frames in sec {median_bw_two_frames / self.abf.dataRate}: &quot;</span>
            <span class="c1">#       f&quot;{1 / (median_bw_two_frames / self.abf.dataRate)} Hz&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_active_frames</span> <span class="o">&gt;</span> <span class="n">frames_gap_threshold</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># first we calculate the sampling rate of the movie</span>
            <span class="c1"># print(f&quot;self.ci_frames_indices[0] {self.ci_frames_indices[0]}&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate_calcium_imaging</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> \
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># contains the sampling rate of each movie recorded</span>
                <span class="n">movies_sampling_rate</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gap_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">):</span>
                    <span class="n">first_frame_segment</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># estimating the sampling rate of the movie</span>
                    <span class="n">segment_time_in_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">gap_index</span><span class="p">]]</span> <span class="o">-</span> \
                                         <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">first_frame_segment</span><span class="p">]]</span>
                    <span class="n">movies_sampling_rate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">segment_time_in_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">gap_index</span> <span class="o">-</span> <span class="n">first_frame_segment</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
                    <span class="c1"># print(f&quot;movie_sampling_rate {movie_sampling_rate} Hz&quot;)</span>
                    <span class="c1"># print(f&quot;gap in frames {gap_in_sec*movie_sampling_rate}&quot;)</span>

                <span class="c1"># estimating the sampling rate of the movie on the last segment</span>
                <span class="n">segment_time_in_ms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> \
                                     <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="n">movies_sampling_rate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="mi">1</span> <span class="o">/</span> <span class="p">((</span><span class="n">segment_time_in_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_rate_calcium_imaging</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">movies_sampling_rate</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;movie_sampling_rate </span><span class="si">{self.sampling_rate_calcium_imaging}</span><span class="s2"> Hz&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fusion_movie_segments</span><span class="p">:</span>
                    <span class="c1"># given the conversion factor to get the timestamps in sec</span>
                    <span class="c1"># we record them in ms to have a better precision</span>
                    <span class="n">ci_frames_bool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_ms</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                    <span class="n">ci_frames_bool</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ci_frames_time_series</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;ci_frames&quot;</span><span class="p">,</span>
                        <span class="n">data</span><span class="o">=</span><span class="n">ci_frames_bool</span><span class="p">,</span>
                        <span class="n">timestamps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">,</span>
                        <span class="c1"># conversion=0.001,</span>
                        <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="c1"># record the data as an acquisition</span>
                    <span class="c1"># to recover the data do: nwb_file.get_acquisition(name=name_channel)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">nwb_file</span><span class="o">.</span><span class="n">add_acquisition</span><span class="p">(</span><span class="n">ci_frames_time_series</span><span class="p">)</span>
                    <span class="c1"># pause_time_intervals = TimeIntervals</span>
                    <span class="n">columns_pause</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">columns_pause</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;start_time&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Start time of epoch, in seconds&quot;</span><span class="p">})</span>
                    <span class="n">columns_pause</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;stop_time&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Stop time of epoch, in seconds&quot;</span><span class="p">})</span>
                    <span class="n">columns_pause</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;start_original_frame&quot;</span><span class="p">,</span>
                                          <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Frame after which the pause starts, using frames from the&quot;</span>
                                                         <span class="s2">&quot;original concatenated movie&quot;</span><span class="p">})</span>
                    <span class="n">columns_pause</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;stop_original_frame&quot;</span><span class="p">,</span>
                                          <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Frame at which the pause ends, using frames from the &quot;</span>
                                                         <span class="s2">&quot;original concatenated movie&quot;</span><span class="p">})</span>
                    <span class="n">pause_time_intervals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nwb_file</span><span class="o">.</span><span class="n">create_time_intervals</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;ci_recording_on_pause&quot;</span><span class="p">,</span>
                                                         <span class="n">description</span><span class="o">=</span><span class="s1">&#39;Intervals that correspond to &#39;</span>
                                                                     <span class="s1">&#39;the time of last frame recorded &#39;</span>
                                                                     <span class="s1">&#39;before the pause, and stop_time &#39;</span>
                                                                     <span class="s1">&#39;is the time of the first frame &#39;</span>
                                                                     <span class="s1">&#39;recorded after the pause, during calcium imaging&#39;</span>
                                                                     <span class="s1">&#39;recording.&#39;</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns_pause</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gap_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gap_indices</span><span class="p">):</span>
                        <span class="c1"># print(f&quot;gap_index {gap_index}&quot;)</span>
                        <span class="c1"># gap_in_ms = self.timestamps_in_ms[self.ci_frames_indices[gap_index + 1]] - \</span>
                        <span class="c1">#              self.timestamps_in_ms[self.ci_frames_indices[gap_index]]</span>
                        <span class="c1"># gap_in_frames = (gap_in_ms / 1000) * self.sampling_rate_calcium_imaging</span>
                        <span class="c1"># the gap in frames is rounded in the floor.</span>

                        <span class="c1"># we save as a TimeInterval the interval during which the calcium imaging movie recording</span>
                        <span class="c1"># is on pause. First value is the time of last frame recorded before the pause, and stop_time</span>
                        <span class="c1"># is the time of the first frame recorded after the pause</span>
                        <span class="c1"># print(&quot;self.nwb_file.add_epoch&quot;)</span>
                        <span class="c1"># issue with add_epoch, it does work but after saving, when loading the nwb_file, there is no</span>
                        <span class="c1"># epoch. Solution using add_time_intervals inspired by this issue</span>
                        <span class="c1"># https://github.com/NeurodataWithoutBorders/pynwb/issues/958</span>
                        <span class="c1"># TODO: See to report an issue on the github</span>
                        <span class="c1"># self.nwb_file.add_epoch(start_time=self.timestamps_in_sec[self.ci_frames_indices[gap_index]],</span>
                        <span class="c1">#                         stop_time=self.timestamps_in_sec[self.ci_frames_indices[gap_index + 1]],</span>
                        <span class="c1">#                         timeseries=ci_frames_time_series,</span>
                        <span class="c1">#                         tags=[&#39;ci_recording_on_pause&#39;])</span>
                        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;start_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">gap_index</span><span class="p">]]</span>
                        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;stop_time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">gap_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;start_original_frame&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_index</span>
                        <span class="n">data_dict</span><span class="p">[</span><span class="s2">&quot;stop_original_frame&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gap_index</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">pause_time_intervals</span><span class="o">.</span><span class="n">add_row</span><span class="p">(</span><span class="n">data_dict</span><span class="p">)</span>

                        <span class="c1"># we add those intervals during which the CI recording is on pause as invalid_time</span>
                        <span class="c1"># so those time intervals will be removed from analysis&#39;</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">nwb_file</span><span class="o">.</span><span class="n">add_invalid_time_interval</span><span class="p">(</span>
                            <span class="n">start_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">gap_index</span><span class="p">]],</span>
                            <span class="n">stop_time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">[</span><span class="n">gap_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="ConvertAbfToNWB.detect_run_periods"><a class="viewcode-back" href="../../../preprocessing.html#cicada.preprocessing.convert_abf_to_nwb.ConvertAbfToNWB.detect_run_periods">[docs]</a>    <span class="k">def</span> <span class="nf">detect_run_periods</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_data</span><span class="p">,</span> <span class="n">min_speed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the data from the abf regarding the speed of the animal on the treadmill, return the speed in cm/s</span>
<span class="sd">        at each timestamps as well as period when the animal is moving (using min_speed threshold)</span>

<span class="sd">        Args:</span>
<span class="sd">            run_data (list): Data from the subject run</span>
<span class="sd">            min_speed (int): Minimum speed</span>

<span class="sd">        Returns:</span>
<span class="sd">            mvt_periods (list): List of movements periods</span>
<span class="sd">            speed_during_movement_periods (list) : List of subject speed during movements</span>
<span class="sd">            speed_by_time (list) : List of subject speed by time</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nb_period_by_wheel</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="n">wheel_diam_cm</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.75</span>
        <span class="n">cm_by_period</span> <span class="o">=</span> <span class="n">wheel_diam_cm</span> <span class="o">/</span> <span class="n">nb_period_by_wheel</span>
        <span class="n">binary_mvt_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">)</span>
        <span class="n">speed_by_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run_data</span><span class="p">))</span>
        <span class="n">is_running</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">run_data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;int8&quot;</span><span class="p">)</span>

        <span class="n">binary_mvt_data</span><span class="p">[</span><span class="n">run_data</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">d_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">binary_mvt_data</span><span class="p">)</span>
        <span class="n">pos_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">d_times</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pos_times</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">run_duration</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">pos_times</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">run_duration_s</span> <span class="o">=</span> <span class="n">run_duration</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span>
            <span class="c1"># in cm/s</span>
            <span class="n">speed</span> <span class="o">=</span> <span class="n">cm_by_period</span> <span class="o">/</span> <span class="n">run_duration_s</span>
            <span class="k">if</span> <span class="n">speed</span> <span class="o">&gt;=</span> <span class="n">min_speed</span><span class="p">:</span>
                <span class="n">speed_by_time</span><span class="p">[</span><span class="n">pos_times</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">speed</span>
                <span class="n">is_running</span><span class="p">[</span><span class="n">pos_times</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1">#  1024 cycle = 1 tour de roue (= 2 Pi 1.5) -&gt; Vitesse (cm / temps pour 1024 cycles).</span>
        <span class="c1"># the period of time between two 1 represent a run</span>
        <span class="n">mvt_periods</span> <span class="o">=</span> <span class="n">get_continous_time_periods</span><span class="p">(</span><span class="n">is_running</span><span class="p">)</span>
        <span class="n">mvt_periods</span> <span class="o">=</span> <span class="n">merging_time_periods</span><span class="p">(</span><span class="n">time_periods</span><span class="o">=</span><span class="n">mvt_periods</span><span class="p">,</span>
                                           <span class="n">min_time_between_periods</span><span class="o">=</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">dataRate</span><span class="p">)</span>

        <span class="n">speed_during_mvt_periods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">period</span> <span class="ow">in</span> <span class="n">mvt_periods</span><span class="p">:</span>
            <span class="n">speed_during_mvt_periods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">speed_by_time</span><span class="p">[</span><span class="n">period</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">period</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">mvt_periods</span><span class="p">,</span> <span class="n">speed_during_mvt_periods</span><span class="p">,</span> <span class="n">speed_by_time</span></div>

<div class="viewcode-block" id="ConvertAbfToNWB.process_run_data"><a class="viewcode-back" href="../../../preprocessing.html#cicada.preprocessing.convert_abf_to_nwb.ConvertAbfToNWB.process_run_data">[docs]</a>    <span class="k">def</span> <span class="nf">process_run_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">run_channel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the information in run_channel, will add to the nwb_file the speed of the subject at each acquisition</span>
<span class="sd">        frame of the movie in cm/s</span>

<span class="sd">        Args:</span>
<span class="sd">            run_channel (int) : Run channel</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">setSweep</span><span class="p">(</span><span class="n">sweepNumber</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">run_channel</span><span class="p">)</span>
        <span class="n">run_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abf</span><span class="o">.</span><span class="n">sweepY</span>
        <span class="n">mvt_periods</span><span class="p">,</span> <span class="n">speed_during_mvt_periods</span><span class="p">,</span> <span class="n">speed_by_time</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">detect_run_periods</span><span class="p">(</span><span class="n">run_data</span><span class="o">=</span><span class="n">run_data</span><span class="p">,</span> <span class="n">min_speed</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">speed_by_time</span> <span class="o">=</span> <span class="n">speed_by_time</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">]</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Source: https://pynwb.readthedocs.io/en/latest/tutorials/domain/brain_observatory.html#sphx-glr-tutorials-domain-brain-observatory-py</span>
<span class="sd">        Adding the speed at each frame acquisition in cm/s    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">running_speed_time_series</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;running_speed&#39;</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">speed_by_time</span><span class="p">,</span>
            <span class="n">timestamps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestamps_in_sec</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ci_frames_indices</span><span class="p">],</span>
            <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;cm/s&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nwb_file</span><span class="o">.</span><span class="n">add_acquisition</span><span class="p">(</span><span class="n">running_speed_time_series</span><span class="p">)</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, CICADA

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>